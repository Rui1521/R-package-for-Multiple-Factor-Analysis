{
    "collab_server" : "",
    "contents" : "#' mfa\n#'\n#' Multiple Factor Analysis\n#'\n#' @include classes.R\n#' @param data data set (matrix or data frame). Dimensions must be observations X variables.\n#' @param sets list of vectors indicating the sets of variables (i.e. the mfa blocks).\n#' @param ncomps integer indicating how many components (i.e. factors) should be used in the dimensionality reduction.\n#' @param center either a logical value or a numeric vector of length equal to the number of active\n#' variables in the analysis. (passed to the \\code{scale} function)\n#' @param scale either a logical value or a numeric vector of length equal to the number of active\n#' variables in the analysis (passed to the \\code{scale} function)\n#'\n#' @return\n#' The returned value is an object of class \"mfa\" with the following elements: \\cr\n#' \\code{eigenvalues} a vector containing eigenvalues for the final factors \\cr\n#' \\code{cfs} a matrix of common factor scores \\cr\n#' \\code{pfs} a list of partial factor scores for each table \\cr\n#' \\code{loadings} a matrix of loadings \\cr\n#' \\code{a_weights} alpha weight for each table \\cr\n#'\n#' @importFrom methods new\n#' @export\n\n# main function\nmfa = function(data, sets, ncomps = NULL, center = TRUE, scale = TRUE){\n  # main function\n  sets = convert_sets(data, sets)\n  data1 = preprocess(data,center,scale)\n  res = compromise_stats(data1,sets,ncomps)\n  create_mfa(res, sets, center, scale, ncomps, data)\n}\n\n# helper functions for mfa\nconvert_sets = function(data, sets){\n  #convert the names of active variables to column indices\n  lapply(sets, function(x){\n    if(class(x)==\"character\"){\n      which(colnames(data)%in%x)\n    }else{\n      x\n    }\n  })\n}\n\npreprocess = function(data, center=TRUE, scale=TRUE){\n  # preprocessing: center + normalize\n  d = scale(as.matrix(data), center = center, scale = scale)\n  apply(d, 2, function(x){sign(x) * sqrt(x^2/sum(x^2))})\n}\n\nsplit_tables = function(data, sets, bycol=TRUE){\n  # split tables\n  if(bycol){\n    l = lapply(sets, function(x){data[,x]})\n  } else{\n    l = lapply(sets, function(x){data[x,]})\n  }\n}\n\nalpha_weight = function(tables){\n  # collect the values of the alpha weights of all tables into a weight vector\n  sapply(tables, function(x){1/(svd(x)$d[1])^2})\n}\n\nweight_matrix = function(tables, alphas){\n  # create weight matrix according to alpha weights returned from pca for each table\n  nc = sapply(tables, ncol)\n  diag(rep(alphas, times=nc))\n}\n\npartial_factor_score = function(tables, set, a, Q, ncomps=NULL){\n  K = length(tables)\n  Qs = split_tables(Q, set, bycol=FALSE)\n  pfs = list()\n  for (i in 1:K){\n    if (is.null(ncomps)){\n      pfs[[i]] = K * a[i] * tables[[i]] %*% Qs[[i]]\n    }else{\n      pfs[[i]] = K * a[i] * tables[[i]] %*% Qs[[i]][,1:ncomps]\n    }\n  }\n  return(pfs)\n}\n\ncompromise_stats = function(data, sets, ncomps){\n  # Using other subfunctions, run a standard PCA on the corrected\n  # dataset to find the compromise.\n  tables = split_tables(data,sets)\n  a = alpha_weight(tables)\n  A = weight_matrix(tables, a)\n  M = diag(rep(1/nrow(data), nrow(data))) #diagonal mass matrix\n  W = as.matrix(data)\n  W_weighted = sqrt(M)%*%W%*%sqrt(A)\n  SVD_compromise = svd(W_weighted)\n  M2 = diag(1/sqrt(diag(M)))\n  A2 = diag(1/sqrt(diag(A)))\n  P = M2%*%SVD_compromise$u\n  Q = A2%*%SVD_compromise$v\n  d = SVD_compromise$d\n  eigenvalues = d^2\n  cfs = P%*%diag(d)\n  pfs = partial_factor_score(tables, sets, a, Q, ncomps)\n  return(list(d=d,eigenvalues=eigenvalues,cfs=cfs,pfs=pfs,Q=Q,A=A))\n}\n\ncreate_mfa = function(res, sets, center, scale, ncomps, data){\n  # create mfa class object\n  if (is.null(ncomps)){\n    new(Class = \"mfa\",\n        data = data, # include the original dataset for method use\n        ncomps = length(res$eigenvalues),\n        sets = sets,\n        center = center,\n        scale = scale,\n        singularValue = res$d,\n        eigenvalues = res$eigenvalues,\n        cfs = res$cfs,\n        pfs = res$pfs,\n        loadings = res$Q,\n        a_weights = diag(res$A))\n  }else{\n    new(Class = \"mfa\",\n        data = data, # include the original dataset for method use\n        ncomps = ncomps,\n        sets = sets,\n        center = center,\n        scale = scale,\n        singularValue = res$d[1:ncomps],\n        eigenvalues = res$eigenvalues[1:ncomps],\n        cfs = res$cfs[,1:ncomps],\n        pfs = res$pfs,\n        loadings = res$Q[,1:ncomps],\n        a_weights = diag(res$A))\n  }\n}\n",
    "created" : 1480400304469.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "520294239",
    "id" : "68D636E7",
    "lastKnownWriteTime" : 1480486235,
    "last_content_update" : 1480486235911,
    "path" : "C:/Users/admin/Desktop/MFA/R/mfa.R",
    "project_path" : "R/mfa.R",
    "properties" : {
        "docOutlineVisible" : "0",
        "tempName" : "Untitled1"
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}